*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="foxrun.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS asynccommand AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cclass		&& Class containing command (if applicable).
		*p: ccommand		&& Command.
		*p: ccommandtype		&& Command type.
		*p: cinapplication		&& Application containing class library.
		*p: cmodule		&& Module/Class Library containing command (if applicable).
		*a: aparameters[1,1]		&& Parameter array.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cclass = 		&& Class containing command (if applicable).
	ccommand = 		&& Command.
	ccommandtype = 		&& Command type.
	cinapplication = 		&& Application containing class library.
	cmodule = 		&& Module/Class Library containing command (if applicable).
	Name = "asynccommand"
	_memberdata = <VFPData>
		<memberdata name="ccommandtype" display="cCommandType"/>
		<memberdata name="ccommand" display="cCommand"/>
		<memberdata name="cclass" display="cClass"/>
		<memberdata name="cmodule" display="cModule"/>
		<memberdata name="cinapplication" display="cInApplication"/>
		<memberdata name="aparameters" display="aParameters"/>
		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS foxrun AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: call		&& Execute/call function.
		*m: callasync		&& Execute/call function (async).
		*m: callmethod		&& Instantiate object and execute/call class method.
		*m: callmethodasync		&& Instantiate object and execute/call class method (async).
		*m: callobjectmethod		&& Call method on existing FoxPro object. Used by CallObjectMethodAsync() or maybe extension methods.
		*m: callobjectmethodasync		&& Call method on existing FoxPro object (async).
		*m: createnewobject		&& Create and return new object.
		*m: createnewobjectasync		&& Create and return new object (async).
		*m: createparameterclause		&& Create parameter clause with specified number of parameters.
		*m: do		&& Execute program.
		*m: doasync		&& Execute program (async).
		*m: docmd		&& Execute single command.
		*m: docmdasync		&& Execute single command (async).
		*m: eval		&& Evaluate expression.
		*m: evalasync		&& Evaluate expression (async).
		*m: execscript		&& Execute script.
		*m: execscriptasync		&& Execute script (async).
		*m: geterrormessage		&& Get last recorded error.  Requires error handler in Fox app to set _Screen.cErrorMessage.
		*m: loadbreakpoints		&& Load breakpoints from resource file.
		*m: processasynccommand		&& Process async command.
		*m: setasynccommand		&& Setup async command and timer to execute it.
		*m: setasyncexception		&& Set exception in .NET Task Completion Source.
		*m: setbreakpoint		&& Set breakpoint in specified file/location.
		*m: seterrorproperty		&& Set global Object.Property that contains the error message reported by GetErrorMessage(). It must be a property on a global object. A global variable is not sufficient.
		*m: setprivatedatasession		&& Set up private data session for object.
		*m: setstepon		&& SET STEP ON before next call.
		*p: cerrorproperty		&& Name of the global Object.Property that contains the error message reported by GetErrorMessage(). It must be a property on a global object. A global variable is not sufficient.
		*p: lquitondestroy		&& When set to .T., will Quit FoxPro when object is destroyed.
		*p: lsetstepon		&& When .T., will SET STEP ON before next call.
		*p: oasynccommand		&& Async command to execute.
		*p: oasynctimer		&& Timer used to execute async command.
		*p: osession		&& Reference to private data session.
		*p: otaskcompletionsource		&& .NET Task Completion Source object for async commands.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED cerrorproperty,lsetstepon,oasynccommand,oasynctimer,otaskcompletionsource
	cerrorproperty = _Screen.cErrorMessage		&& Name of the global Object.Property that contains the error message reported by GetErrorMessage(). It must be a property on a global object. A global variable is not sufficient.
	lquitondestroy = .F.		&& When set to .T., will Quit FoxPro when object is destroyed.
	lsetstepon = .F.		&& When .T., will SET STEP ON before next call.
	Name = "foxrun"
	oasynccommand = 		&& Async command to execute.
	oasynctimer = 		&& Timer used to execute async command.
	osession = .F.		&& Reference to private data session.
	otaskcompletionsource = .NULL.		&& .NET Task Completion Source object for async commands.
	_memberdata = <VFPData>
		<memberdata name="createparameterclause" display="CreateParameterClause"/>
		<memberdata name="call" display="Call"/>
		<memberdata name="callmethod" display="CallMethod"/>
		<memberdata name="do" display="Do"/>
		<memberdata name="docmd" display="DoCmd"/>
		<memberdata name="eval" display="Eval"/>
		<memberdata name="execscript" display="ExecScript"/>
		<memberdata name="createnewobject" display="CreateNewObject"/>
		<memberdata name="lquitondestroy" display="lQuitOnDestroy"/>
		<memberdata name="geterrormessage" display="GetErrorMessage"/>
		<memberdata name="osession" display="oSession"/>
		<memberdata name="setprivatedatasession" display="SetPrivateDataSession"/>
		<memberdata name="setasynccommand" display="SetAsyncCommand"/>
		<memberdata name="oasynccommand" display="oAsyncCommand"/>
		<memberdata name="oasynctimer" display="oAsyncTimer"/>
		<memberdata name="processasynccommand" display="ProcessAsyncCommand"/>
		<memberdata name="evalasync" display="EvalAsync"/>
		<memberdata name="otaskcompletionsource" display="oTaskCompletionSource"/>
		<memberdata name="doasync" display="DoAsync"/>
		<memberdata name="setasyncexception" display="SetAsyncException"/>
		<memberdata name="docmdasync" display="DoCmdAsync"/>
		<memberdata name="callasync" display="CallAsync"/>
		<memberdata name="callmethodasync" display="CallMethodAsync"/>
		<memberdata name="createnewobjectasync" display="CreateNewObjectAsync"/>
		<memberdata name="execscriptasync" display="ExecScriptAsync"/>
		<memberdata name="callobjectmethodasync" display="CallObjectMethodAsync"/>
		<memberdata name="callobjectmethod" display="CallObjectMethod"/>
		<memberdata name="lsetstepon" display="lSetStepOn"/>
		<memberdata name="setstepon" display="SetStepOn"/>
		<memberdata name="setbreakpoint" display="SetBreakpoint"/>
		<memberdata name="cerrorproperty" display="cErrorProperty"/>
		<memberdata name="seterrorproperty" display="SetErrorProperty"/>
		<memberdata name="loadbreakpoints" display="LoadBreakpoints"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE call		&& Execute/call function.
		* Execute/call function
		Lparameters lcFunction, laParameters
		Local lcParameterClause, lcFunctionCall
		
		lcParameterClause = This.CreateParameterClause(@laParameters)
		
		Debugout Time(0), Program(), lcFunction, lcParameterClause 
			
		lcFunctionCall = Alltrim(lcFunction)+ "(" + lcParameterClause + ")"
		
		If This.lSetStepOn and _VFP.StartMode = 1
			This.lSetStepOn = .f.
			Set Step On
			* Step into &lcFunctionCall below
		EndIf 
		
		Return &lcFunctionCall
		
		
	ENDPROC

	PROCEDURE callasync		&& Execute/call function (async).
		* Execute/call function (async)
		Lparameters loTaskCompletionSource, lcFunction, laParameters
		
		Debugout Time(0), Program(), lcFunction
		
		This.SetAsyncCommand("CALL", loTaskCompletionSource, lcFunction,,,, @laParameters)
	ENDPROC

	PROCEDURE callmethod		&& Instantiate object and execute/call class method.
		* Instantiate object and execute/call class method.
		Lparameters lcMethod, lcClassName, lcModule, lcInApplication, laParameters
		Local lcParameterClause, lcMethodCall, loObject
			
		lcInApplication = Evl(lcInApplication, "")
		lcParameterClause = This.CreateParameterClause(@laParameters)
		
		Debugout Time(0), Program(), lcMethod, lcClassName, lcModule, lcInApplication, lcParameterClause 
			
		If This.lSetStepOn and _VFP.StartMode = 1
			This.lSetStepOn = .f.
			Set Step On
			* Step into NewObject() or loObject.&lcMethodCall below
		EndIf 
		
		loObject = NewObject(lcClassName, lcModule, lcInApplication)
		lcMethodCall = Alltrim(lcMethod)+ "(" + lcParameterClause + ")"
		Return loObject.&lcMethodCall
		
		
	ENDPROC

	PROCEDURE callmethodasync		&& Instantiate object and execute/call class method (async).
		* Instantiate object and execute/call class method (async)
		Lparameters loTaskCompletionSource, lcMethod, lcClassName, lcModule, lcInApplication, laParameters
		
		Debugout Time(0), Program(), lcMethod, lcClassName, lcModule, lcInApplication
		
		This.SetAsyncCommand("CALLMETHOD", loTaskCompletionSource, lcMethod, lcClassName, lcModule, lcInApplication, @laParameters)
		
	ENDPROC

	PROCEDURE callobjectmethod		&& Call method on existing FoxPro object. Used by CallObjectMethodAsync() or maybe extension methods.
		* Call method on existing FoxPro object. 
		* Used by CallObjectMethodAsync() or maybe extension methods.
		Lparameters loObject, lcMethod, laParameters
		Local lcParameterClause, lcMethodCall
			
		lcParameterClause = This.CreateParameterClause(@laParameters)
		
		Debugout Time(0), Program(), loObject.Name, lcMethod, lcParameterClause 
			
		lcMethodCall = Alltrim(lcMethod)+ "(" + lcParameterClause + ")"
		
		If This.lSetStepOn and _VFP.StartMode = 1
			This.lSetStepOn = .f.
			Set Step On
			* Step into loObject.&lcMethodCall below
		EndIf 
		
		Return loObject.&lcMethodCall
	ENDPROC

	PROCEDURE callobjectmethodasync		&& Call method on existing FoxPro object (async).
		* Call method on existing FoxPro object (async)
		Lparameters loTaskCompletionSource, loObject, lcMethod, laParameters
		
		Debugout Time(0), Program(), loObject.Name, lcMethod
		
		This.SetAsyncCommand("CALLOBJECTMETHOD", loTaskCompletionSource, lcMethod, loObject,,, @laParameters)
	ENDPROC

	PROCEDURE createnewobject		&& Create and return new object.
		* Create and return new object.
		Lparameters lcClassName, lcModule, lcInApplication, laParameters
		Local lcParameterClause, loObject
			
		lcInApplication = Evl(lcInApplication, "")
		
		lcParameterClause = This.CreateParameterClause(@laParameters)
		If !Empty(lcParameterClause)
			Debugout Time(0), Program(), lcClassName, lcModule, lcInApplication, lcParameterClause 
			If This.lSetStepOn and _VFP.StartMode = 1
				This.lSetStepOn = .f.
				Set Step On
				* Step into NewObject() call below
			EndIf 
			loObject = NewObject(lcClassName, lcModule, lcInApplication, &lcParameterClause)
		Else 
			Debugout Time(0), Program(), lcClassName, lcModule, lcInApplication
			If This.lSetStepOn and _VFP.StartMode = 1
				This.lSetStepOn = .f.
				Set Step On
				* Step into NewObject() call below
			EndIf 
			loObject = NewObject(lcClassName, lcModule, lcInApplication)
		EndIf 
		
		Return loObject
		
	ENDPROC

	PROCEDURE createnewobjectasync		&& Create and return new object (async).
		* Create and return new object (async)
		Lparameters loTaskCompletionSource, lcClassName, lcModule, lcInApplication, laParameters
		
		Debugout Time(0), Program(), lcClassName, lcModule, lcInApplication
		
		This.SetAsyncCommand("CREATENEWOBJECT", loTaskCompletionSource,, lcClassName, lcModule, lcInApplication, @laParameters)
	ENDPROC

	PROTECTED PROCEDURE createparameterclause		&& Create parameter clause with specified number of parameters.
		* Create parameter clause with specified number of parameters
		* Pass in parameter variables by reference ("out" variables)
		Lparameters laParameters
		Local lnParameter, lcParameter, lcParameterClause, lnPCount
		
		Debugout Time(0), Program()
		
		lcParameterClause = ""
		If Type("laParameters", 1) = "A"
			lnPCount = Alen(laParameters)
			For lnParameter = 1 to lnPCount
				* Parameters are in array
				lcParameter = "laParameters[" + Transform(lnParameter) + "]"
				If !Empty(lcParameterClause)
					lcParameterClause = lcParameterClause + ", "
				EndIf 
				lcParameterClause = lcParameterClause + lcParameter
			EndFor 
		EndIf 
		
		Return lcParameterClause
		
		
	ENDPROC

	PROCEDURE Destroy
		* Optionally quit when object destroyed
		Debugout Time(0), Program()
		
		* ? Time(0), Program()
		* Clean up and release data session
		*JAL*	Set Datasession To This.oSession.DataSessionID
		*JAL*	Close Databases All
		Set Datasession To 1
		This.oSession = .f.
		
		* Make sure debugger not left open
		If _VFP.StartMode = 1
			Release Windows "Visual FoxPro Debugger"
		EndIf 
		
		If This.lQuitOnDestroy
			Quit
		EndIf 
		
	ENDPROC

	PROCEDURE do		&& Execute program.
		* Execute program
		Lparameters lcPRG, lcInProgram, laParameters
		Local lcParameterClause
		
		lcInProgram = Evl(lcInProgram, "")
		
		lcParameterClause = This.CreateParameterClause(@laParameters)
		If !Empty(lcParameterClause)
			* DO passes all parameters by reference, so strip out "@" to avoid syntax error
		*JAL*		lcParameterClause = Chrtran(lcParameterClause, "@", "")
			Debugout Time(0), Program(), lcPRG, lcInProgram, lcParameterClause
			If This.lSetStepOn and _VFP.StartMode = 1
				This.lSetStepOn = .f.
				Set Step On
				* Step into DO call below
			EndIf 
			Do (lcPRG) in (lcInProgram) with &lcParameterClause
		Else 
			Debugout Time(0), Program(), lcPRG, lcInProgram
			If This.lSetStepOn and _VFP.StartMode = 1
				This.lSetStepOn = .f.
				Set Step On
				* Step into DO call below
			EndIf 
			Do (lcPRG) in (lcInProgram)
		EndIf 
		
		* No return value from DO command, so always .T.
	ENDPROC

	PROCEDURE doasync		&& Execute program (async).
		* Execute program (async)
		Lparameters loTaskCompletionSource, lcPRG, lcInProgram, laParameters
		
		Debugout Time(0), Program(), lcPRG, lcInProgram
		
		This.SetAsyncCommand("DO", loTaskCompletionSource, lcPRG, lcInProgram,,, @laParameters)
	ENDPROC

	PROCEDURE docmd		&& Execute single command.
		Lparameters lcCommand
		
		Debugout Time(0), Program(), lcCommand
		
		If This.lSetStepOn and _VFP.StartMode = 1
			This.lSetStepOn = .f.
			Set Step On
			* Step into &lcCommand below
		EndIf 
		
		&lcCommand
		
		* Return _VFP.DoCmd(lcCommand)
		
		
	ENDPROC

	PROCEDURE docmdasync		&& Execute single command (async).
		* Evaluate single command (async)
		Lparameters loTaskCompletionSource, lcCommand
		
		Debugout Time(0), Program(), lcCommand
		
		This.SetAsyncCommand("DOCMD", loTaskCompletionSource, lcCommand)
	ENDPROC

	PROCEDURE eval		&& Evaluate expression.
		Lparameters lcExpression
		
		Debugout Time(0), Program(), lcExpression
		
		If This.lSetStepOn and _VFP.StartMode = 1
			This.lSetStepOn = .f.
			Set Step On
			* Step into Evaluate() call below
		EndIf 
		
		Return Evaluate(lcExpression)
		
		* Return _VFP.Eval(lcExpression)
	ENDPROC

	PROCEDURE evalasync		&& Evaluate expression (async).
		* Evaluate expression (async)
		Lparameters loTaskCompletionSource, lcExpression
		
		Debugout Time(0), Program(), lcExpression
		
		This.SetAsyncCommand("EVAL", loTaskCompletionSource, lcExpression)
	ENDPROC

	PROCEDURE execscript		&& Execute script.
		* Execute script
		Lparameters lcScript, laParameters
		Local lcParameterClause
		
		lcParameterClause = This.CreateParameterClause(@laParameters)
		If !Empty(lcParameterClause)
			Debugout Time(0), Program(), "(Script)", lcParameterClause 
			If This.lSetStepOn and _VFP.StartMode = 1
				This.lSetStepOn = .f.
				Set Step On
				* Step into ExecScript() call below
			EndIf 
			Return ExecScript(lcScript, &lcParameterClause)
		Else
			Debugout Time(0), Program(), "(Script)"
			If This.lSetStepOn and _VFP.StartMode = 1
				This.lSetStepOn = .f.
				Set Step On
				* Step into ExecScript() call below
			EndIf 
			Return ExecScript(lcScript)
		EndIf 
		
		
	ENDPROC

	PROCEDURE execscriptasync		&& Execute script (async).
		* Execute script (async)
		Lparameters loTaskCompletionSource, lcScript, laParameters
		
		Debugout Time(0), Program(), "(Script)"
		
		This.SetAsyncCommand("EXECSCRIPT", loTaskCompletionSource, lcScript,,,, @laParameters)
		
	ENDPROC

	PROCEDURE geterrormessage		&& Get last recorded error.  Requires error handler in Fox app to set _Screen.cErrorMessage.
		* Get last recorded error.  
		* Requires error handler in Fox app to set property specified in This.cErrorProperty (_Screen.cErrorMessage by default).
		Local lcErrorMessage, lcErrorProperty
		
		lcErrorMessage = ""
		lcErrorProperty = This.cErrorProperty
		If Type(lcErrorProperty) = "C"
			lcErrorMessage = Evaluate(lcErrorProperty)
			* Reset error message
			&lcErrorProperty = ""
		EndIf 
		
		Return lcErrorMessage
		
	ENDPROC

	PROCEDURE Init
		This.SetPrivateDataSession()
		
		Return DoDefault()
	ENDPROC

	PROCEDURE loadbreakpoints		&& Load breakpoints from resource file.
		* Load breakpoints from resource file.
		Lparameters lcResourceFile
		Local lnCurrentArea, lcBreakpoints, lcConfigFile, lcClipText
		
		If _VFP.StartMode > 1
			Return 
		EndIf 
		
		If Empty(lcResourceFile)
			lcResourceFile = Sys(2005)
		EndIf 
		
		lnCurrentArea = Select()
		
		* Get breakpoints from resource file
		Select 0
		Use Sys(2005) Again 
		Locate for ID = "BPOINTS"
		If Found()
			lcBreakpoints = StrExtract(Data, "DBGCFGVERSION", "", 1, 4)
		EndIf 
		Use 
		
		* Copy breakpoints to config file and load into debugger
		If !Empty(lcBreakpoints)
			lcConfigFile = Addbs(Sys(2023)) + "Breakpoints" + Sys(2015) + Transform(_VFP.ThreadId) + ".dbg"
			Erase (lcConfigFile)
			StrToFile(lcBreakpoints, lcConfigFile)
			Debug
			* Clipboard is faster than typing filename
			lcClipText = _ClipText
			_ClipText = lcConfigFile
			Keyboard "{F2}{CTRL+V}{ENTER}"	
			Doevents 
			_ClipText = lcClipText
			Erase (lcConfigFile)
		EndIf 
		
		Select (lnCurrentArea)
	ENDPROC

	PROCEDURE processasynccommand		&& Process async command.
		* Process Async Command
		* Called by tmrAsync
		Local loAsyncCommand as ASyncCommand of FoxRun.vcx, lcCommandType, lvReturn, laParameters, loTaskCompletionSource
		Local loErrorObject, lcErrorProperty
		loAsyncCommand = This.oAsyncCommand	&& for Intellisense
		
		Assert !IsNull(loAsyncCommand) Message Program() + " Command object is NULL"
		
		Debugout Time(0), Program(), loAsyncCommand.cCommandType, loAsyncCommand.cCommand, ;
			loAsyncCommand.cClass, loAsyncCommand.cModule
			
		* If error occurs, set exception in Task Completion Source	
		* Called via BindEvent() if error message is set
		loErrorObject = Evaluate(JustStem(This.cErrorProperty))
		lcErrorProperty = JustExt(This.cErrorProperty)
		BindEvent(loErrorObject, lcErrorProperty, This, "SetAsyncException", 1)
		
		lcCommandType = Upper(Alltrim(loAsyncCommand.cCommandType))
		If Type("loAsyncCommand.aParameters", 1) = "A" and !(Vartype(loAsyncCommand.aParameters[1]) = "L" and loAsyncCommand.aParameters[1] = .F.)
			Dimension laParameters[1]	&& change to array
			Acopy(loAsyncCommand.aParameters, laParameters)
		EndIf 
		
		Do Case
		Case lcCommandType == "EVAL"
			lvReturn = This.Eval(loAsyncCommand.cCommand)
		Case lcCommandType == "DOCMD"
			lvReturn = This.DoCmd(loAsyncCommand.cCommand)
		Case lcCommandType == "DO"
			lvReturn = This.Do(loAsyncCommand.cCommand, loAsyncCommand.cClass, @laParameters)
		Case lcCommandType == "CALL"
			lvReturn = This.Call(loAsyncCommand.cCommand, @laParameters)
		Case lcCommandType == "CALLMETHOD"
			lvReturn = This.CallMethod(loAsyncCommand.cCommand, loAsyncCommand.cClass, loAsyncCommand.cModule, loAsyncCommand.cInApplication, @laParameters)
		Case lcCommandType == "EXECSCRIPT"
			lvReturn = This.ExecScript(loAsyncCommand.cCommand, @laParameters)
		Case lcCommandType == "CREATENEWOBJECT"
			lvReturn = This.CreateNewObject(loAsyncCommand.cClass, loAsyncCommand.cModule, loAsyncCommand.cInApplication, @laParameters)
		Case lcCommandType == "CALLOBJECTMETHOD"
			lvReturn = This.CallObjectMethod(loAsyncCommand.cClass, loAsyncCommand.cCommand, @laParameters)
		Otherwise
		
		EndCase
		
		UnBindEvents(loErrorObject, lcErrorProperty, This, "SetAsyncException")
		
		* Set result in Task Completion Source
		* This triggers .NET that the command is complete
		* Release property references before setting result, or they could affect next call
		loTaskCompletionSource = This.oTaskCompletionSource
		This.oTaskCompletionSource = NULL
		This.oAsyncCommand = NULL
		loTaskCompletionSource.SetResult(lvReturn)
		
	ENDPROC

	PROTECTED PROCEDURE setasynccommand		&& Setup async command and timer to execute it.
		* Setup async command and timer to execute it
		Lparameters lcCommandType, loTaskCompletionSource, lcCommand, lcClass, lcModule, lcInApplication, laParameters
		Local loAsyncCommand as ASyncCommand of FoxRun.vcx
		
		Debugout Time(0), Program(), lcCommandType, lcCommand, lcClass, lcModule
		
		This.oTaskCompletionSource = loTaskCompletionSource
		
		* Create command object
		loAsyncCommand = NewObject("AsyncCommand", This.ClassLibrary)
		loAsyncCommand.cCommandType = Evl(lcCommandType, "")
		loAsyncCommand.cCommand = Evl(lcCommand, "")
		* cClass can be set to object
		loAsyncCommand.cClass = Iif(Vartype(lcClass) = "O", lcClass, Evl(lcClass, ""))
		loAsyncCommand.cModule = Evl(lcModule, "")
		loAsyncCommand.cInApplication = Evl(lcInApplication, "")
		If Type("laParameters", 1) = "A"
			Acopy(laParameters, loAsyncCommand.aParameters)
		EndIf 
		
		This.oAsyncCommand = loAsyncCommand 
		
		If Vartype(This.oAsyncTimer) <> "O" or IsNull(This.oAsyncTimer)
			This.oAsyncTimer = NewObject("tmrAsync", This.ClassLibrary)
		EndIf 
		
		* Timer is used to start command without blocking main process
		This.oAsyncTimer.ProcessCommand(This)
		
	ENDPROC

	PROCEDURE setasyncexception		&& Set exception in .NET Task Completion Source.
		If !Empty(Evaluate(This.cErrorProperty))
			* Set exception in Task Completion Source
			* This triggers .NET that the command is complete
			* Release property references before setting result, or they could affect next call
			loTaskCompletionSource = This.oTaskCompletionSource
			This.oTaskCompletionSource = NULL
			This.oAsyncCommand = NULL
			loTaskCompletionSource.SetException()
		EndIf 
	ENDPROC

	PROCEDURE setbreakpoint		&& Set breakpoint in specified file/location.
		* Set breakpoint in specified file/location
		* Location should be in same format as VFP Breakpoints dialog
		Lparameters lcFilename, lcLocation
		
		If _VFP.StartMode = 1
			* No way to programmatically set breakpoint, so populates Breakpoints dialog using keyboard commands
			* {CTRL+B} is hotkey to open Breakpoints dialog
			* Hotkey may not be available on menu, so open Debugger first.
			Debug
			Keyboard Textmerge("{CTRL+B}<<lcLocation>>{TAB}<<lcFilename>>{ENTER}{ENTER}")
		EndIf 
	ENDPROC

	PROCEDURE seterrorproperty		&& Set global Object.Property that contains the error message reported by GetErrorMessage(). It must be a property on a global object. A global variable is not sufficient.
		* Set global Object.Property that contains the error message reported by GetErrorMessage(). 
		* It must be a property on a global object. A global variable is not sufficient.
		Lparameters lcErrorPropertyName
		Local loErrorObject, lcErrorProperty
		
		* Create and reset error message property
		lcErrorPropertyName = Evl(lcErrorPropertyName, This.cErrorProperty)
		This.cErrorProperty = Alltrim(lcErrorPropertyName)
		If Type(lcErrorPropertyName) = "U"
			loErrorObject = Evaluate(JustStem(lcErrorPropertyName))
			lcErrorProperty = JustExt(lcErrorPropertyName)
			AddProperty(loErrorObject, lcErrorProperty, "")
		EndIf 
		&lcErrorPropertyName = ""
	ENDPROC

	PROTECTED PROCEDURE setprivatedatasession		&& Set up private data session for object.
		* Set up private data session for object
		This.oSession = CreateObject("Session")
		This.oSession.Name = This.Name
		Set Datasession To This.oSession.DataSessionID
		Set Deleted On
		Set Multilocks On
		Set TablePrompt Off
		* DebugInfo("Using Session "+Alltrim(Str(Set("Datasession"))))
		Debugout Time(0), Program(), Alltrim(Str(Set("Datasession")))
		
		
	ENDPROC

	PROCEDURE setstepon		&& SET STEP ON before next call.
		* SET STEP ON before next call
		* lSetStepOn Property will be checked before each call
		This.lSetStepOn = .t. 
	ENDPROC

ENDDEFINE

DEFINE CLASS tmrasync AS timer 
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: processcommand		&& Process current command.
		*p: lprocessed		&& Is .T. if command already processed.
		*p: ofoxrun		&& FoxRun class that processes command.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Enabled = .F.
	Height = 23
	Interval = 1
	lprocessed = 		&& Is .T. if command already processed.
	Name = "tmrasync"
	ofoxrun = .NULL.		&& FoxRun class that processes command.
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="processcommand" display="ProcessCommand"/>
		<memberdata name="lprocessed" display="lProcessed"/>
		<memberdata name="ofoxrun" display="oFoxRun"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE processcommand		&& Process current command.
		* Process current command
		Lparameters loFoxRun as FoxRun of FoxRun.vcx
		
		This.oFoxRun = loFoxRun
		This.lProcessed = .f.
		This.Enabled = .t.
		
	ENDPROC

	PROCEDURE Timer
		* Worker Command timer
		* Timer is used to process command so main thread does not
		*	wait on command to complete.
		* Timer is enabled for each command and only fires once.
		Local loFoxRun as FoxRun of FoxRun.vcx
		
		This.Enabled = .f.
		Doevents 
		* Timer can fire more than once before it is disabled.
		* Doevents usually prevents this from happening, but this code ensures it.
		If This.lProcessed
			Return 
		EndIf 
		This.lProcessed = .t.
		
		* Hold reference to manager for minimum time to help avoid dangling objects
		loFoxRun = This.oFoxRun
		This.oFoxRun = NULL
		loFoxRun.ProcessAsyncCommand() 
		
	ENDPROC

ENDDEFINE
